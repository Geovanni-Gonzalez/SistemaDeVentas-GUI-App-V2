from src.database import DatabaseManager
from src.logger import log_error, log_info

class Repository:
    def __init__(self, table_name):
        self.table_name = table_name

    def load_all(self, mapper_func):
        # mapper_func: class.from_row
        conn = DatabaseManager.get_connection()
        cursor = conn.cursor()
        items = []
        try:
            cursor.execute(f"SELECT * FROM {self.table_name}")
            rows = cursor.fetchall()
            for row in rows:
                items.append(mapper_func(row))
        except Exception as e:
            log_error(f"Error loading from {self.table_name}", e)
        finally:
            conn.close()
        return items

    def create(self, obj):
        conn = DatabaseManager.get_connection()
        cursor = conn.cursor()
        try:
            # Dynamically build INSERT
            # Assuming obj attributes match table columns map or manually handling it
            # To be safe and generic is hard in raw SQL without ORM. 
            # I will implement specific insert logic based on table name for simplicity and robustness.
            
            if self.table_name == "categorias":
                cursor.execute("INSERT INTO categorias (nombre) VALUES (?)", (obj.nombre,))
            
            elif self.table_name == "productos":
                cursor.execute("INSERT INTO productos (nombre, categoria_id, proveedor_id, cantidad, precio) VALUES (?, ?, ?, ?, ?)",
                               (obj.nombre, obj.categoria_id, obj.proveedor_id, obj.cantidad, obj.precio))
            
            elif self.table_name == "clientes":
                cursor.execute("INSERT INTO clientes (cedula, nombre, provincia, telefono, correo) VALUES (?, ?, ?, ?, ?)",
                               (obj.cedula, obj.nombre, obj.provincia, obj.telefono, obj.correo))
            
            elif self.table_name == "proveedores":
                cursor.execute("INSERT INTO proveedores (cedula, nombre, telefono, correo) VALUES (?, ?, ?, ?)",
                               (obj.cedula, obj.nombre, obj.telefono, obj.correo))
            
            elif self.table_name == "ordenes":
                cursor.execute("INSERT INTO ordenes (proveedor_id, fecha, total) VALUES (?, ?, ?)",
                               (obj.proveedor_id, obj.fecha, obj.total))
                # Note: This just inserts header. ID is autogenerated. 
                # Ideally we return the ID.
                obj.codigo = cursor.lastrowid
                
            elif self.table_name == "facturas":
                cursor.execute("INSERT INTO facturas (cliente_id, fecha, total) VALUES (?, ?, ?)",
                               (obj.cliente_id, obj.fecha, obj.total))
                obj.codigo = cursor.lastrowid

            conn.commit()
            return obj.codigo if hasattr(obj, 'codigo') else cursor.lastrowid

        except Exception as e:
            log_error(f"Error creating in {self.table_name}", e)
            conn.rollback()
            raise e
        finally:
            conn.close()

    def update(self, obj):
        # Update logic based on 'codigo' (or 'id' for users)
        conn = DatabaseManager.get_connection()
        cursor = conn.cursor()
        try:
            if self.table_name == "categorias":
                cursor.execute("UPDATE categorias SET nombre=? WHERE codigo=?", (obj.nombre, obj.codigo))
            
            elif self.table_name == "productos":
                cursor.execute("UPDATE productos SET nombre=?, categoria_id=?, proveedor_id=?, cantidad=?, precio=? WHERE codigo=?",
                               (obj.nombre, obj.categoria_id, obj.proveedor_id, obj.cantidad, obj.precio, obj.codigo))
            
            elif self.table_name == "clientes":
                cursor.execute("UPDATE clientes SET cedula=?, nombre=?, provincia=?, telefono=?, correo=? WHERE codigo=?",
                               (obj.cedula, obj.nombre, obj.provincia, obj.telefono, obj.correo, obj.codigo))

            elif self.table_name == "proveedores":
                cursor.execute("UPDATE proveedores SET cedula=?, nombre=?, telefono=?, correo=? WHERE codigo=?",
                               (obj.cedula, obj.nombre, obj.telefono, obj.correo, obj.codigo))
            
            # Stock updates (special case if used)
            elif self.table_name == "productos_stock":
                # Special update just for stock
                pass

            conn.commit()
        except Exception as e:
            log_error(f"Error updating {self.table_name}", e)
            raise e
        finally:
            conn.close()

    def delete(self, _id):
        conn = DatabaseManager.get_connection()
        cursor = conn.cursor()
        try:
            col = "id" if self.table_name == "usuarios" else "codigo"
            cursor.execute(f"DELETE FROM {self.table_name} WHERE {col}=?", (_id,))
            conn.commit()
        except Exception as e:
            log_error(f"Error deleting from {self.table_name}", e)
            raise e
        finally:
            conn.close()
            
    # Helper to append (Previous code called append) - Map to create
    def append(self, obj):
        return self.create(obj)
    
    # Helper to save_all (Previous code called this) - Map to update one by one?
    # Actually, legacy save_all rewrote entire file.
    # We should NOT implementation save_all usually, but for compatibility:
    def save_all(self, items):
        # In SQL, we don't save all. We update individual items.
        # But legacy UI might be iterating and updating object in memory then calling save_all.
        # We really should update line by line.
        # For this refactor, I will leave this blank or log warning, 
        # because I will change the UI to call update() explicitly.
        pass
